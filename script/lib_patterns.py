import fnmatch

PATTERNS = {

    ###
    # These patterns are used to reorganize the KiCad libraries
    # Filters are not case sensitive
    #

    ###
    # The following filters are used to rename an entire library
    ###

    'microchip_pic10mcu' : 'mcu_microchip_pic10',
    'microchip_pic12mcu' : 'mcu_microchip_pic12',
    'microchip_pic16mcu' : 'mcu_microchip_pic16',
    'microchip_pic18mcu' : 'mcu_microchip_pic18',
    'microchip_pic24mcu' : 'mcu_microchip_pic24',
    'microchip_pic32mcu' : 'mcu_microchip_pic32',

    'microchip_dspic33dsc' : 'dsp_microchip_dspic33',

    'stm32' : 'mcu_st_stm32',
    'stm8' : 'mcu_st_stm8',

    'nxp_armmcu' : 'mcu_nxp_lpc',

    'power' : 'power',

    'motors' : 'motor',

    'driver_gate' : 'driver_gate',

    ###
    # The following filters are used to separate symbols out from various libraries
    ###

    # adc-dac library
    'adc-dac:mcp4801*' : 'analog_dac',
    'adc-dac:mcp355*' : 'analog_adc',
}

###
# This is a list of required libraries
# If they are not generated by moving other symbols to them,
# they will be added (as empty libraries)
###

REQUIRED_LIBS = [
    # Basic Devices
    "device",
    "led",
    "motor",
    "power",
    "pspice",
    "relay",
    "switch",

    # Connectors
    "connector",

    # Virtual Symbols
    "graphical_symbol",
    "logo",
    "mechanical",

    # Simple semiconductors
    "diode",
    "esd_protection",
    "transistor",
    "thyristor",
    "valve",

    # Displays
    "display_character",
    "display_graphic",
    "display_segment",

    # Transformers
    "transformer",
    "transformer_power",
    "transformer_pulse",
    "transformer_signal",

    # Sensors
    "sensor",
    "sensor_current",
    "sensor_humidity",
    "sensor_magnetic",
    "sensor_motion",
    "sensor_multi-function",
    "sensor_photo",
    "sensor_pressure",
    "sensor_temperature",

    # Audio / Video
    "audio_adc_dac",
    "audio_codec",
    "audio_misc",
    "video",

    # Linear Devices
    "amplifier_audio",
    "amplifier_current_sense",
    "amplifier_difference",
    "amplifier_instrumentation",
    "amplifier_operational",
    "amplifier_rf",
    "amplifier_video",
    "comparator",

    # References
    "reference_current",
    "reference_voltage",

    # Power Management
    "battery",
    "battery_management",
    "power_conditioning",
    "power_distribution",
    "power_monitor",
    "power_supervisor",
    "power_module_ac-dc",
    "power_module_ac-ac",
    "power_module_dc-dc",
    "power_module_dc-ac",

    # Voltage Regulators
    "regulator_linear",
    "regulator_linear_controller",
    "regulator_switching",
    "regulator_switching_controller",
    "regulator_switching_module",

    # Mixed Signal
    "adc",
    "adc_dac",
    "analog_switch",
    "dac",
    "digital_pot",

    # Drivers
    "driver_led",
    "driver_gate",
    "driver_motor",

    # Timers
    "timer",
    "timer_oscillator",
    "timer_pll",
    "timer_rtc",

    # Logic
    "logic",
    "logic_74xx",
    "logic_cmos40xx",
    "logic_translator",

    # Isolators
    "isolator.lib",
    "isolator_analog.lib",

    # CPLD
    "cpld",
    "cpld_altera_intel",
    "cpld_xilinx",

    # FPGA
    "fpga",
    "fpga_actel",
    "fpga_altera_intel",
    "fpga_atmel",
    "fpga_xilinx",

    # MCU
    "mcu",
    "mcu_8048",
    "mcu_8051",
    "mcu_atmel_avr",
    "mcu_atmel_avr32",
    "mcu_atmel_arm",
    "mcu_cypress",
    "mcu_cypress_arm",
    "mcu_microchip_pic10",
    "mcu_microchip_pic12",
    "mcu_microchip_pic16",
    "mcu_microchip_pic18",
    "mcu_microchip_pic24",
    "mcu_microchip_pic32",
    "mcu_freescale_hc",
    "mcu_freescale_coldfire",
    "mcu_infineon_c166",
    "mcu_nxp_lpc",
    "mcu_parallax",
    "mcu_renesas",
    "mcu_st_stm32",
    "mcu_st_stm8",
    "mcu_texas_msp430",

    # CPU
    "cpu",
    "cpu_intel_x86",
    "cpu_amd_x86",
    "cpu_motorola_68000",
    "cpu_motorola_powerpc",
    "cpu_zilog_z80",

    # DSP
    "dsp",
    "dsp_microchip_dspic33",
    "dsp_texas",
    "dsp_freescale",

    # SOC
    "soc",
    "soc_texas_arm",

    # Memory
    "memory",
    "memory_card",
    "memory_controller",
    "memory_eeprom",
    "memory_flash",
    "memory_nvram",
    "memory_vram",

    # Interface
    "interface",
    "interface_bluetooth",
    "interface_can_lin",
    "interface_ethernet",
    "interface_i2c",
    "interface_lvds",
    "interface_rf",
    "interface_spi",
    "interface_telecom",
    "interface_uart",
    "interface_usb",
    "interface_wifi",
    "interface_video",
    "interface_zigbee",
]

def get_lib_name(pattern):
    return pattern.split(':')[0].lower()

def get_part_filter(pattern):

    s = pattern.split(':')

    # Match all the things!!
    if len(s) < 2:
        return '*'

    return s[1].lower()

def get_output_lib(pattern):
    return PATTERNS[pattern]

def is_entire_lib(pattern):

    """
    Determine if a library pattern designates the entire library
    """

    return get_part_filter(pattern) == '*'


def get_entire_lib_match(lib_name):

    """
    If the library is to be moved entirely,
    return the destination library.
    Otherwise, return None
    """

    lib_name = lib_name.lower()

    for pattern in PATTERNS:
        if not is_entire_lib(pattern):
            continue

        if get_lib_name(pattern) == lib_name:
            return get_output_lib(pattern)

    return None


def get_matches(lib_name, cmp_name):

    lib_name = lib_name.lower()
    cmp_name = cmp_name.lower()

    """
    Return any matches for a lib_name:cmp_name pair
    """

    matches = []

    for pattern in PATTERNS:
        if is_entire_lib(pattern):
            continue

        if not get_lib_name(pattern) == lib_name:
            continue

        part_filter = get_part_filter(pattern)

        # An exact match overrides all other filters
        if part_filter == cmp_name:
            return [part_filter]

        if fnmatch.fnmatch(cmp_name, part_filter):
            matches.append(get_output_lib(pattern))


    return matches